#ifndef __DEFAULT_SOURCE4_TORTURE_SMB2_PROTO_H__
#define __DEFAULT_SOURCE4_TORTURE_SMB2_PROTO_H__

#undef _PRINTF_ATTRIBUTE
#define _PRINTF_ATTRIBUTE(a1, a2) PRINTF_ATTRIBUTE(a1, a2)
/* This file was automatically generated by mkproto.pl. DO NOT EDIT */

/* this file contains prototypes for functions that are private 
 * to this subsystem or library. These functions should not be 
 * used outside this particular subsystem! */


/* The following definitions come from ../source4/torture/smb2/connect.c  */

bool torture_smb2_connect(struct torture_context *torture);

/* The following definitions come from ../source4/torture/smb2/scan.c  */

struct torture_suite *torture_smb2_scan_init(void);

/* The following definitions come from ../source4/torture/smb2/util.c  */

NTSTATUS smb2_util_write(struct smb2_tree *tree,
			 struct smb2_handle handle, 
			 const void *buf, off_t offset, size_t size);
NTSTATUS smb2_create_complex_file(struct smb2_tree *tree, const char *fname, 
					 struct smb2_handle *handle);
NTSTATUS smb2_create_complex_dir(struct smb2_tree *tree, const char *fname, 
				 struct smb2_handle *handle);
void torture_smb2_all_info(struct smb2_tree *tree, struct smb2_handle handle);

/**
 * open a smb2 tree connect
 */
bool torture_smb2_tree_connect(struct torture_context *tctx,
			       struct smb2_session *session,
			       TALLOC_CTX *mem_ctx,
			       struct smb2_tree **_tree);

/**
 * do a smb2 session setup (without a tree connect)
 */
bool torture_smb2_session_setup(struct torture_context *tctx,
				struct smb2_transport *transport,
				uint64_t previous_session_id,
				TALLOC_CTX *mem_ctx,
				struct smb2_session **_session);
bool torture_smb2_connection_ext(struct torture_context *tctx,
				 uint64_t previous_session_id,
				 struct smb2_tree **tree);
bool torture_smb2_connection(struct torture_context *tctx, struct smb2_tree **tree);
NTSTATUS torture_smb2_testfile(struct smb2_tree *tree, const char *fname, 
			       struct smb2_handle *handle);
NTSTATUS torture_smb2_testdir(struct smb2_tree *tree, const char *fname, 
			      struct smb2_handle *handle);
NTSTATUS torture_setup_complex_file(struct smb2_tree *tree, const char *fname);
NTSTATUS torture_setup_complex_dir(struct smb2_tree *tree, const char *fname);
NTSTATUS smb2_util_roothandle(struct smb2_tree *tree, struct smb2_handle *handle);
bool smb2_util_setup_dir(struct torture_context *tctx, struct smb2_tree *tree,
    const char *dname);
bool smb2_util_verify_sd(TALLOC_CTX *tctx, struct smb2_tree *tree,
    struct smb2_handle handle, struct security_descriptor *sd);
bool smb2_util_verify_attrib(TALLOC_CTX *tctx, struct smb2_tree *tree,
    struct smb2_handle handle, uint32_t attrib);
uint32_t smb2_util_lease_state(const char *ls);
uint32_t smb2_util_share_access(const char *sharemode);
uint8_t smb2_util_oplock_level(const char *op);

/**
 * Helper functions to fill a smb2_create struct for several
 * open scenarios.
 */
void smb2_generic_create_share(struct smb2_create *io, struct smb2_lease *ls,
			       bool dir, const char *name, uint32_t disposition,
			       uint32_t share_access,
			       uint8_t oplock, uint64_t leasekey,
			       uint32_t leasestate);
void smb2_generic_create(struct smb2_create *io, struct smb2_lease *ls,
			 bool dir, const char *name, uint32_t disposition,
			 uint8_t oplock, uint64_t leasekey,
			 uint32_t leasestate);
void smb2_lease_create_share(struct smb2_create *io, struct smb2_lease *ls,
			     bool dir, const char *name, uint32_t share_access,
			     uint64_t leasekey, uint32_t leasestate);
void smb2_lease_create(struct smb2_create *io, struct smb2_lease *ls,
		       bool dir, const char *name, uint64_t leasekey,
		       uint32_t leasestate);
void smb2_oplock_create_share(struct smb2_create *io, const char *name,
			      uint32_t share_access, uint8_t oplock);
void smb2_oplock_create(struct smb2_create *io, const char *name, uint8_t oplock);

/* The following definitions come from ../source4/torture/smb2/getinfo.c  */

bool torture_smb2_getinfo(struct torture_context *torture);

/* The following definitions come from ../source4/torture/smb2/setinfo.c  */

bool torture_smb2_setinfo(struct torture_context *tctx);

/* The following definitions come from ../source4/torture/smb2/lock.c  */


/**
 * Test truncation of locked file
 *  - some tests ported from BASE-LOCK-LOCK7
 */
struct torture_suite *torture_smb2_lock_init(void);

/* The following definitions come from ../source4/torture/smb2/notify.c  */

struct torture_suite *torture_smb2_notify_init(void);

/* The following definitions come from ../source4/torture/smb2/smb2.c  */

struct torture_test *torture_suite_add_1smb2_test(struct torture_suite *suite,
						  const char *name,
						  bool (*run)(struct torture_context *,
							      struct smb2_tree *));
struct torture_test *torture_suite_add_2smb2_test(struct torture_suite *suite,
						  const char *name,
						  bool (*run)(struct torture_context *,
							      struct smb2_tree *,
							      struct smb2_tree *));
NTSTATUS torture_smb2_init(void);

/* The following definitions come from ../source4/torture/smb2/durable_open.c  */


/**
 * basic durable_open test.
 * durable state should only be granted when requested
 * along with a batch oplock or a handle lease.
 *
 * This test tests durable open with all possible oplock types.
 */
bool test_durable_open_open_oplock(struct torture_context *tctx,
				   struct smb2_tree *tree);

/**
 * basic durable_open test.
 * durable state should only be granted when requested
 * along with a batch oplock or a handle lease.
 *
 * This test tests durable open with all valid lease types.
 */
bool test_durable_open_open_lease(struct torture_context *tctx,
				  struct smb2_tree *tree);

/**
 * basic test for doing a durable open
 * and do a durable reopen on the same connection
 * while the first open is still active (fails)
 */
bool test_durable_open_reopen1(struct torture_context *tctx,
			       struct smb2_tree *tree);

/**
 * basic test for doing a durable open
 * tcp disconnect, reconnect, do a durable reopen (succeeds)
 */
bool test_durable_open_reopen2(struct torture_context *tctx,
			       struct smb2_tree *tree);

/**
 * basic test for doing a durable open
 * tcp disconnect, reconnect with a session reconnect and
 * do a durable reopen (succeeds)
 */
bool test_durable_open_reopen2a(struct torture_context *tctx,
			        struct smb2_tree *tree);

/**
 * basic test for doing a durable open:
 * tdis, new tcon, try durable reopen (fails)
 */
bool test_durable_open_reopen3(struct torture_context *tctx,
			       struct smb2_tree *tree);

/**
 * basic test for doing a durable open:
 * logoff, create a new session, do a durable reopen (succeeds)
 */
bool test_durable_open_reopen4(struct torture_context *tctx,
			       struct smb2_tree *tree);
bool test_durable_open_delete_on_close1(struct torture_context *tctx,
					struct smb2_tree *tree);
bool test_durable_open_delete_on_close2(struct torture_context *tctx,
					struct smb2_tree *tree);
bool test_durable_open_file_position(struct torture_context *tctx,
				     struct smb2_tree *tree);
bool test_durable_open_oplock(struct torture_context *tctx,
			      struct smb2_tree *tree1,
			      struct smb2_tree *tree2);
bool test_durable_open_lease(struct torture_context *tctx,
			     struct smb2_tree *tree1,
			     struct smb2_tree *tree2);
bool test_durable_open_lock_oplock(struct torture_context *tctx,
				   struct smb2_tree *tree);
bool test_durable_open_lock_lease(struct torture_context *tctx,
				  struct smb2_tree *tree);

/**
 * Open with a RH lease, disconnect, open in another tree, reconnect.
 *
 * This test actually demonstrates a minimum level of respect for the durable
 * open in the face of another open. As long as this test shows an inability to
 * reconnect after an open, the oplock/lease tests above will certainly
 * demonstrate an error on reconnect.
 */
bool test_durable_open_open2_lease(struct torture_context *tctx,
				  struct smb2_tree *tree1,
				  struct smb2_tree *tree2);

/**
 * Open with a batch oplock, disconnect, open in another tree, reconnect.
 *
 * This test actually demonstrates a minimum level of respect for the durable
 * open in the face of another open. As long as this test shows an inability to
 * reconnect after an open, the oplock/lease tests above will certainly
 * demonstrate an error on reconnect.
 */
bool test_durable_open_open2_oplock(struct torture_context *tctx,
				    struct smb2_tree *tree1,
				    struct smb2_tree *tree2);

/**
 * test behaviour with initial allocation size
 */
bool test_durable_open_alloc_size(struct torture_context *tctx,
				  struct smb2_tree *tree);
struct torture_suite *torture_smb2_durable_open_init(void);

/* The following definitions come from ../source4/torture/smb2/durable_v2_open.c  */


/**
 * basic durable_open test.
 * durable state should only be granted when requested
 * along with a batch oplock or a handle lease.
 *
 * This test tests durable open with all possible oplock types.
 */
bool test_durable_v2_open_oplock(struct torture_context *tctx,
				 struct smb2_tree *tree);

/**
 * basic durable handle open test.
 * persistent state should only be granted when requested
 * along with a batch oplock or a handle lease.
 *
 * This test tests persistent open with all valid lease types.
 */
bool test_durable_v2_open_lease(struct torture_context *tctx,
				struct smb2_tree *tree);

/**
 * basic test for doing a durable open
 * and do a durable reopen on the same connection
 * while the first open is still active (fails)
 */
bool test_durable_v2_open_reopen1(struct torture_context *tctx,
				  struct smb2_tree *tree);

/**
 * basic test for doing a durable open
 * tcp disconnect, reconnect, do a durable reopen (succeeds)
 */
bool test_durable_v2_open_reopen2(struct torture_context *tctx,
				  struct smb2_tree *tree);

/**
 * basic persistent open test.
 *
 * This test tests durable open with all possible oplock types.
 */
bool test_persistent_open_oplock(struct torture_context *tctx,
				 struct smb2_tree *tree);

/**
 * basic persistent handle open test.
 * persistent state should only be granted when requested
 * along with a batch oplock or a handle lease.
 *
 * This test tests persistent open with all valid lease types.
 */
bool test_persistent_open_lease(struct torture_context *tctx,
				struct smb2_tree *tree);
struct torture_suite *torture_smb2_durable_v2_open_init(void);

/* The following definitions come from ../source4/torture/smb2/oplock.c  */

struct torture_suite *torture_smb2_oplocks_init(void);
bool test_smb2_bench_oplock(struct torture_context *tctx,
				   struct smb2_tree *tree);
bool test_smb2_hold_oplock(struct torture_context *tctx,
			   struct smb2_tree *tree);

/* The following definitions come from ../source4/torture/smb2/dir.c  */

NTSTATUS torture_single_file_search(struct smb2_tree *tree,
				    TALLOC_CTX *mem_ctx,
				    const char *pattern,
				    uint8_t level,
				    enum smb_search_data_level data_level,
				    int idx,
				    union smb_search_data *d,
				    unsigned int *count,
				    struct smb2_handle *h);
bool fill_result(void *private_data,
		 union smb_search_data *file,
		 int count,
		 uint8_t level,
		 enum smb_search_data_level data_level);
struct torture_suite *torture_smb2_dir_init(void);

/* The following definitions come from ../source4/torture/smb2/lease.c  */


/**
 * upgrade2 test.
 * full matrix of lease upgrade combinations
 */
struct torture_suite *torture_smb2_lease_init(void);

/* The following definitions come from ../source4/torture/smb2/create.c  */

struct torture_suite *torture_smb2_create_init(void);

/* The following definitions come from ../source4/torture/smb2/acls.c  */

struct torture_suite *torture_smb2_acls_init(void);

/* The following definitions come from ../source4/torture/smb2/read.c  */

struct torture_suite *torture_smb2_read_init(void);

/* The following definitions come from ../source4/torture/smb2/compound.c  */

struct torture_suite *torture_smb2_compound_init(void);

/* The following definitions come from ../source4/torture/smb2/streams.c  */

struct torture_suite *torture_smb2_streams_init(void);

/* The following definitions come from ../source4/torture/smb2/ioctl.c  */

struct torture_suite *torture_smb2_ioctl_init(void);

/* The following definitions come from ../source4/torture/smb2/rename.c  */

struct torture_suite *torture_smb2_rename_init(void);

/* The following definitions come from ../source4/torture/smb2/session.c  */


/**
 * basic test for doing a session reconnect
 */
bool test_session_reconnect1(struct torture_context *tctx, struct smb2_tree *tree);

/**
 * basic test for doing a session reconnect on one connection
 */
bool test_session_reconnect2(struct torture_context *tctx, struct smb2_tree *tree);
bool test_session_reauth1(struct torture_context *tctx, struct smb2_tree *tree);
bool test_session_reauth2(struct torture_context *tctx, struct smb2_tree *tree);

/**
 * test getting security descriptor after reauth
 */
bool test_session_reauth3(struct torture_context *tctx, struct smb2_tree *tree);

/**
 * test setting security descriptor after reauth.
 */
bool test_session_reauth4(struct torture_context *tctx, struct smb2_tree *tree);

/**
 * test renaming after reauth.
 * compare security descriptors before and after rename/reauth
 */
bool test_session_reauth5(struct torture_context *tctx, struct smb2_tree *tree);
struct torture_suite *torture_smb2_session_init(void);
#undef _PRINTF_ATTRIBUTE
#define _PRINTF_ATTRIBUTE(a1, a2)

#endif /* __DEFAULT_SOURCE4_TORTURE_SMB2_PROTO_H__ */

