
/* Python wrapper functions auto-generated by pidl */
#include <Python.h>
#include "includes.h"
#include <pytalloc.h>
#include "librpc/rpc/pyrpc.h"
#include "librpc/rpc/pyrpc_util.h"
#include "bin/default/source4/librpc/gen_ndr/ndr_winbind.h"
#include "bin/default/source4/librpc/gen_ndr/ndr_winbind_c.h"

#include "librpc/gen_ndr/netlogon.h"
#include "librpc/gen_ndr/lsa.h"
#include "librpc/gen_ndr/security.h"
#include "librpc/gen_ndr/idmap.h"
staticforward PyTypeObject winbind_InterfaceType;

void initwinbind(void);static PyTypeObject *NL_DNS_NAME_INFO_ARRAY_Type;
static PyTypeObject *id_map_Type;
static PyTypeObject *ClientConnection_Type;

static bool pack_py_winbind_information_args_in(PyObject *args, PyObject *kwargs, struct winbind_information *r)
{
	const char *kwnames[] = {
		NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, ":winbind_information", discard_const_p(char *, kwnames))) {
		return false;
	}

	return true;
}

static PyObject *unpack_py_winbind_information_args_out(struct winbind_information *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	return result;
}

static bool pack_py_winbind_remote_control_args_in(PyObject *args, PyObject *kwargs, struct winbind_remote_control *r)
{
	const char *kwnames[] = {
		NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, ":winbind_remote_control", discard_const_p(char *, kwnames))) {
		return false;
	}

	return true;
}

static PyObject *unpack_py_winbind_remote_control_args_out(struct winbind_remote_control *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}

static bool pack_py_winbind_SamLogon_args_in(PyObject *args, PyObject *kwargs, struct winbind_SamLogon *r)
{
	PyObject *py_logon_level;
	PyObject *py_logon;
	PyObject *py_validation_level;
	const char *kwnames[] = {
		"logon_level", "logon", "validation_level", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:winbind_SamLogon", discard_const_p(char *, kwnames), &py_logon_level, &py_logon, &py_validation_level)) {
		return false;
	}

	PY_CHECK_TYPE(&PyInt_Type, py_logon_level, return false;);
	r->in.logon_level = PyInt_AsLong(py_logon_level);
	{
		union netr_LogonLevel *logon_switch_0;
		logon_switch_0 = py_export_netr_LogonLevel(r, r->in.logon_level, py_logon);
		if (logon_switch_0 == NULL) {
			return false;
		}
		r->in.logon = *logon_switch_0;
	}
	PY_CHECK_TYPE(&PyInt_Type, py_validation_level, return false;);
	r->in.validation_level = PyInt_AsLong(py_validation_level);
	return true;
}

static PyObject *unpack_py_winbind_SamLogon_args_out(struct winbind_SamLogon *r)
{
	PyObject *result;
	PyObject *py_validation;
	PyObject *py_authoritative;
	result = PyTuple_New(2);
	py_validation = py_import_netr_Validation(r, r->in.validation_level, &r->out.validation);
	if (py_validation == NULL) {
		return NULL;
	}
	PyTuple_SetItem(result, 0, py_validation);
	py_authoritative = PyInt_FromLong(r->out.authoritative);
	PyTuple_SetItem(result, 1, py_authoritative);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}

static bool pack_py_winbind_get_idmap_args_in(PyObject *args, PyObject *kwargs, struct winbind_get_idmap *r)
{
	PyObject *py_level;
	PyObject *py_ids;
	const char *kwnames[] = {
		"level", "ids", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:winbind_get_idmap", discard_const_p(char *, kwnames), &py_level, &py_ids)) {
		return false;
	}

	if (PyLong_Check(py_level)) {
		r->in.level = PyLong_AsLongLong(py_level);
	} else if (PyInt_Check(py_level)) {
		r->in.level = PyInt_AsLong(py_level);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
		  PyInt_Type.tp_name, PyLong_Type.tp_name);
		return false;
	}
	PY_CHECK_TYPE(&PyList_Type, py_ids, return false;);
	r->in.count = PyList_GET_SIZE(py_ids);
	PY_CHECK_TYPE(&PyList_Type, py_ids, return false;);
	{
		int ids_cntr_0;
		r->in.ids = talloc_array_ptrtype(r, r->in.ids, PyList_GET_SIZE(py_ids));
		if (!r->in.ids) { return false;; }
		talloc_set_name_const(r->in.ids, "ARRAY: r->in.ids");
		for (ids_cntr_0 = 0; ids_cntr_0 < PyList_GET_SIZE(py_ids); ids_cntr_0++) {
			PY_CHECK_TYPE(id_map_Type, PyList_GET_ITEM(py_ids, ids_cntr_0), return false;);
			if (talloc_reference(r->in.ids, pytalloc_get_mem_ctx(PyList_GET_ITEM(py_ids, ids_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return false;
			}
			r->in.ids[ids_cntr_0] = *(struct id_map *)pytalloc_get_ptr(PyList_GET_ITEM(py_ids, ids_cntr_0));
		}
	}
	return true;
}

static PyObject *unpack_py_winbind_get_idmap_args_out(struct winbind_get_idmap *r)
{
	PyObject *result;
	PyObject *py_ids;
	py_ids = PyList_New(r->in.count);
	if (py_ids == NULL) {
		return NULL;
	}
	{
		int ids_cntr_0;
		for (ids_cntr_0 = 0; ids_cntr_0 < r->in.count; ids_cntr_0++) {
			PyObject *py_ids_0;
			py_ids_0 = pytalloc_reference_ex(id_map_Type, r->out.ids, &r->out.ids[ids_cntr_0]);
			PyList_SetItem(py_ids, ids_cntr_0, py_ids_0);
		}
	}
	result = py_ids;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}

static bool pack_py_winbind_DsrUpdateReadOnlyServerDnsRecords_args_in(PyObject *args, PyObject *kwargs, struct winbind_DsrUpdateReadOnlyServerDnsRecords *r)
{
	PyObject *py_site_name;
	PyObject *py_dns_ttl;
	PyObject *py_dns_names;
	const char *kwnames[] = {
		"site_name", "dns_ttl", "dns_names", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:winbind_DsrUpdateReadOnlyServerDnsRecords", discard_const_p(char *, kwnames), &py_site_name, &py_dns_ttl, &py_dns_names)) {
		return false;
	}

	if (py_site_name == Py_None) {
		r->in.site_name = NULL;
	} else {
		r->in.site_name = NULL;
		if (PyUnicode_Check(py_site_name)) {
			r->in.site_name = PyString_AS_STRING(PyUnicode_AsEncodedString(py_site_name, "utf-8", "ignore"));
		} else if (PyString_Check(py_site_name)) {
			r->in.site_name = PyString_AS_STRING(py_site_name);
		} else {
			PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(py_site_name)->tp_name);
			return false;
		}
	}
	PY_CHECK_TYPE(&PyInt_Type, py_dns_ttl, return false;);
	r->in.dns_ttl = PyInt_AsLong(py_dns_ttl);
	r->in.dns_names = talloc_ptrtype(r, r->in.dns_names);
	PY_CHECK_TYPE(NL_DNS_NAME_INFO_ARRAY_Type, py_dns_names, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_dns_names)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.dns_names = (struct NL_DNS_NAME_INFO_ARRAY *)pytalloc_get_ptr(py_dns_names);
	return true;
}

static PyObject *unpack_py_winbind_DsrUpdateReadOnlyServerDnsRecords_args_out(struct winbind_DsrUpdateReadOnlyServerDnsRecords *r)
{
	PyObject *result;
	PyObject *py_dns_names;
	py_dns_names = pytalloc_reference_ex(NL_DNS_NAME_INFO_ARRAY_Type, r->out.dns_names, r->out.dns_names);
	result = py_dns_names;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}

const struct PyNdrRpcMethodDef py_ndr_winbind_methods[] = {
	{ "information", "S.information() -> None", (py_dcerpc_call_fn)dcerpc_winbind_information_r, (py_data_pack_fn)pack_py_winbind_information_args_in, (py_data_unpack_fn)unpack_py_winbind_information_args_out, 0, &ndr_table_winbind },
	{ "remote_control", "S.remote_control() -> None", (py_dcerpc_call_fn)dcerpc_winbind_remote_control_r, (py_data_pack_fn)pack_py_winbind_remote_control_args_in, (py_data_unpack_fn)unpack_py_winbind_remote_control_args_out, 1, &ndr_table_winbind },
	{ "SamLogon", "S.SamLogon(logon_level, logon, validation_level) -> (validation, authoritative)", (py_dcerpc_call_fn)dcerpc_winbind_SamLogon_r, (py_data_pack_fn)pack_py_winbind_SamLogon_args_in, (py_data_unpack_fn)unpack_py_winbind_SamLogon_args_out, 2, &ndr_table_winbind },
	{ "get_idmap", "S.get_idmap(level, ids) -> ids", (py_dcerpc_call_fn)dcerpc_winbind_get_idmap_r, (py_data_pack_fn)pack_py_winbind_get_idmap_args_in, (py_data_unpack_fn)unpack_py_winbind_get_idmap_args_out, 3, &ndr_table_winbind },
	{ "DsrUpdateReadOnlyServerDnsRecords", "S.DsrUpdateReadOnlyServerDnsRecords(site_name, dns_ttl, dns_names) -> dns_names", (py_dcerpc_call_fn)dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r, (py_data_pack_fn)pack_py_winbind_DsrUpdateReadOnlyServerDnsRecords_args_in, (py_data_unpack_fn)unpack_py_winbind_DsrUpdateReadOnlyServerDnsRecords_args_out, 4, &ndr_table_winbind },
	{ NULL }
};

static PyObject *interface_winbind_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_dcerpc_interface_init_helper(type, args, kwargs, &ndr_table_winbind);
}

static PyTypeObject winbind_InterfaceType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "winbind.winbind",
	.tp_basicsize = sizeof(dcerpc_InterfaceObject),
	.tp_doc = "winbind(binding, lp_ctx=None, credentials=None) -> connection\n"
"\n"
"binding should be a DCE/RPC binding string (for example: ncacn_ip_tcp:127.0.0.1)\n"
"lp_ctx should be a path to a smb.conf file or a param.LoadParm object\n"
"credentials should be a credentials.Credentials object.\n\n",
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = interface_winbind_new,
};

static PyMethodDef winbind_methods[] = {
	{ NULL, NULL, 0, NULL }
};

void initwinbind(void)
{
	PyObject *m;
	PyObject *dep_samba_dcerpc_security;
	PyObject *dep_samba_dcerpc_idmap;
	PyObject *dep_samba_dcerpc_base;
	PyObject *dep_samba_dcerpc_netlogon;
	PyObject *dep_samba_dcerpc_lsa;

	dep_samba_dcerpc_security = PyImport_ImportModule("samba.dcerpc.security");
	if (dep_samba_dcerpc_security == NULL)
		return;

	dep_samba_dcerpc_idmap = PyImport_ImportModule("samba.dcerpc.idmap");
	if (dep_samba_dcerpc_idmap == NULL)
		return;

	dep_samba_dcerpc_base = PyImport_ImportModule("samba.dcerpc.base");
	if (dep_samba_dcerpc_base == NULL)
		return;

	dep_samba_dcerpc_netlogon = PyImport_ImportModule("samba.dcerpc.netlogon");
	if (dep_samba_dcerpc_netlogon == NULL)
		return;

	dep_samba_dcerpc_lsa = PyImport_ImportModule("samba.dcerpc.lsa");
	if (dep_samba_dcerpc_lsa == NULL)
		return;

	NL_DNS_NAME_INFO_ARRAY_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_netlogon, "NL_DNS_NAME_INFO_ARRAY");
	if (NL_DNS_NAME_INFO_ARRAY_Type == NULL)
		return;

	id_map_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_idmap, "id_map");
	if (id_map_Type == NULL)
		return;

	ClientConnection_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_base, "ClientConnection");
	if (ClientConnection_Type == NULL)
		return;

	winbind_InterfaceType.tp_base = ClientConnection_Type;

	if (PyType_Ready(&winbind_InterfaceType) < 0)
		return;
	if (!PyInterface_AddNdrRpcMethods(&winbind_InterfaceType, py_ndr_winbind_methods))
		return;

#ifdef PY_WINBIND_PATCH
	PY_WINBIND_PATCH(&winbind_InterfaceType);
#endif

	m = Py_InitModule3("winbind", winbind_methods, "winbind DCE/RPC");
	if (m == NULL)
		return;

	PyModule_AddObject(m, "WINBIND_IDMAP_LEVEL_XIDS_TO_SIDS", PyInt_FromLong(WINBIND_IDMAP_LEVEL_XIDS_TO_SIDS));
	PyModule_AddObject(m, "WINBIND_IDMAP_LEVEL_SIDS_TO_XIDS", PyInt_FromLong(WINBIND_IDMAP_LEVEL_SIDS_TO_XIDS));
	Py_INCREF((PyObject *)(void *)&winbind_InterfaceType);
	PyModule_AddObject(m, "winbind", (PyObject *)(void *)&winbind_InterfaceType);
#ifdef PY_MOD_WINBIND_PATCH
	PY_MOD_WINBIND_PATCH(m);
#endif

}
