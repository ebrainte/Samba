/* client functions auto-generated by pidl */

#include "includes.h"
#include <tevent.h>
#include "lib/util/tevent_ntstatus.h"
#include "bin/default/source4/librpc/gen_ndr/ndr_winbind.h"
#include "bin/default/source4/librpc/gen_ndr/ndr_winbind_c.h"

/* winbind - client functions generated by pidl */

struct dcerpc_winbind_information_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winbind_information_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winbind_information_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winbind_information *r)
{
	struct tevent_req *req;
	struct dcerpc_winbind_information_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winbind_information_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winbind,
			NDR_WINBIND_INFORMATION, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winbind_information_r_done, req);

	return req;
}

static void dcerpc_winbind_information_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winbind_information_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winbind_information_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winbind_information_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winbind_information_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winbind_information *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winbind,
			NDR_WINBIND_INFORMATION, mem_ctx, r);

	return status;
}

struct dcerpc_winbind_information_state {
	struct winbind_information orig;
	struct winbind_information tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winbind_information_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winbind_information_send(TALLOC_CTX *mem_ctx,
						   struct tevent_context *ev,
						   struct dcerpc_binding_handle *h)
{
	struct tevent_req *req;
	struct dcerpc_winbind_information_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winbind_information_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winbind_information_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winbind_information_done, req);
	return req;
}

static void dcerpc_winbind_information_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winbind_information_state *state = tevent_req_data(
		req, struct dcerpc_winbind_information_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winbind_information_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winbind_information_recv(struct tevent_req *req,
					 TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winbind_information_state *state = tevent_req_data(
		req, struct dcerpc_winbind_information_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winbind_information(struct dcerpc_binding_handle *h,
				    TALLOC_CTX *mem_ctx)
{
	struct winbind_information r;
	NTSTATUS status;

	/* In parameters */

	status = dcerpc_winbind_information_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_winbind_remote_control_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winbind_remote_control_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winbind_remote_control_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winbind_remote_control *r)
{
	struct tevent_req *req;
	struct dcerpc_winbind_remote_control_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winbind_remote_control_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winbind,
			NDR_WINBIND_REMOTE_CONTROL, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winbind_remote_control_r_done, req);

	return req;
}

static void dcerpc_winbind_remote_control_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winbind_remote_control_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winbind_remote_control_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winbind_remote_control_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winbind_remote_control_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winbind_remote_control *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winbind,
			NDR_WINBIND_REMOTE_CONTROL, mem_ctx, r);

	return status;
}

struct dcerpc_winbind_remote_control_state {
	struct winbind_remote_control orig;
	struct winbind_remote_control tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winbind_remote_control_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winbind_remote_control_send(TALLOC_CTX *mem_ctx,
						      struct tevent_context *ev,
						      struct dcerpc_binding_handle *h)
{
	struct tevent_req *req;
	struct dcerpc_winbind_remote_control_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winbind_remote_control_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winbind_remote_control_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winbind_remote_control_done, req);
	return req;
}

static void dcerpc_winbind_remote_control_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winbind_remote_control_state *state = tevent_req_data(
		req, struct dcerpc_winbind_remote_control_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winbind_remote_control_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winbind_remote_control_recv(struct tevent_req *req,
					    TALLOC_CTX *mem_ctx,
					    NTSTATUS *result)
{
	struct dcerpc_winbind_remote_control_state *state = tevent_req_data(
		req, struct dcerpc_winbind_remote_control_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winbind_remote_control(struct dcerpc_binding_handle *h,
				       TALLOC_CTX *mem_ctx,
				       NTSTATUS *result)
{
	struct winbind_remote_control r;
	NTSTATUS status;

	/* In parameters */

	status = dcerpc_winbind_remote_control_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winbind_SamLogon_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winbind_SamLogon_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winbind_SamLogon_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winbind_SamLogon *r)
{
	struct tevent_req *req;
	struct dcerpc_winbind_SamLogon_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winbind_SamLogon_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winbind,
			NDR_WINBIND_SAMLOGON, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winbind_SamLogon_r_done, req);

	return req;
}

static void dcerpc_winbind_SamLogon_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winbind_SamLogon_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winbind_SamLogon_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winbind_SamLogon_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winbind_SamLogon_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winbind_SamLogon *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winbind,
			NDR_WINBIND_SAMLOGON, mem_ctx, r);

	return status;
}

struct dcerpc_winbind_get_idmap_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winbind_get_idmap_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winbind_get_idmap_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winbind_get_idmap *r)
{
	struct tevent_req *req;
	struct dcerpc_winbind_get_idmap_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winbind_get_idmap_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winbind,
			NDR_WINBIND_GET_IDMAP, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winbind_get_idmap_r_done, req);

	return req;
}

static void dcerpc_winbind_get_idmap_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winbind_get_idmap_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winbind_get_idmap_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winbind_get_idmap_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winbind_get_idmap_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winbind_get_idmap *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winbind,
			NDR_WINBIND_GET_IDMAP, mem_ctx, r);

	return status;
}

struct dcerpc_winbind_get_idmap_state {
	struct winbind_get_idmap orig;
	struct winbind_get_idmap tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winbind_get_idmap_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winbind_get_idmap_send(TALLOC_CTX *mem_ctx,
						 struct tevent_context *ev,
						 struct dcerpc_binding_handle *h,
						 enum winbind_get_idmap_level _level /* [in]  */,
						 uint32_t _count /* [in]  */,
						 struct id_map *_ids /* [in,out] [size_is(count)] */)
{
	struct tevent_req *req;
	struct dcerpc_winbind_get_idmap_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winbind_get_idmap_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.level = _level;
	state->orig.in.count = _count;
	state->orig.in.ids = _ids;

	/* Out parameters */
	state->orig.out.ids = _ids;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winbind_get_idmap_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winbind_get_idmap_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winbind_get_idmap_done, req);
	return req;
}

static void dcerpc_winbind_get_idmap_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winbind_get_idmap_state *state = tevent_req_data(
		req, struct dcerpc_winbind_get_idmap_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winbind_get_idmap_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	{
		size_t _copy_len_ids;
		_copy_len_ids = state->tmp.in.count;
		memcpy(state->orig.out.ids, state->tmp.out.ids, _copy_len_ids * sizeof(*state->orig.out.ids));
	}

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winbind_get_idmap_recv(struct tevent_req *req,
				       TALLOC_CTX *mem_ctx,
				       NTSTATUS *result)
{
	struct dcerpc_winbind_get_idmap_state *state = tevent_req_data(
		req, struct dcerpc_winbind_get_idmap_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winbind_get_idmap(struct dcerpc_binding_handle *h,
				  TALLOC_CTX *mem_ctx,
				  enum winbind_get_idmap_level _level /* [in]  */,
				  uint32_t _count /* [in]  */,
				  struct id_map *_ids /* [in,out] [size_is(count)] */,
				  NTSTATUS *result)
{
	struct winbind_get_idmap r;
	NTSTATUS status;

	/* In parameters */
	r.in.level = _level;
	r.in.count = _count;
	r.in.ids = _ids;

	status = dcerpc_winbind_get_idmap_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	{
		size_t _copy_len_ids;
		_copy_len_ids = r.in.count;
		memcpy(_ids, r.out.ids, _copy_len_ids * sizeof(*_ids));
	}

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct winbind_DsrUpdateReadOnlyServerDnsRecords *r)
{
	struct tevent_req *req;
	struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_winbind,
			NDR_WINBIND_DSRUPDATEREADONLYSERVERDNSRECORDS, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_done, req);

	return req;
}

static void dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_state *state =
		tevent_req_data(req,
		struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct winbind_DsrUpdateReadOnlyServerDnsRecords *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_winbind,
			NDR_WINBIND_DSRUPDATEREADONLYSERVERDNSRECORDS, mem_ctx, r);

	return status;
}

struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_state {
	struct winbind_DsrUpdateReadOnlyServerDnsRecords orig;
	struct winbind_DsrUpdateReadOnlyServerDnsRecords tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_send(TALLOC_CTX *mem_ctx,
									 struct tevent_context *ev,
									 struct dcerpc_binding_handle *h,
									 const char *_site_name /* [in] [unique,charset(UTF16)] */,
									 uint32_t _dns_ttl /* [in]  */,
									 struct NL_DNS_NAME_INFO_ARRAY *_dns_names /* [in,out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.site_name = _site_name;
	state->orig.in.dns_ttl = _dns_ttl;
	state->orig.in.dns_names = _dns_names;

	/* Out parameters */
	state->orig.out.dns_names = _dns_names;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_done, req);
	return req;
}

static void dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_state *state = tevent_req_data(
		req, struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.dns_names = *state->tmp.out.dns_names;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_recv(struct tevent_req *req,
							       TALLOC_CTX *mem_ctx,
							       NTSTATUS *result)
{
	struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_state *state = tevent_req_data(
		req, struct dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords(struct dcerpc_binding_handle *h,
							  TALLOC_CTX *mem_ctx,
							  const char *_site_name /* [in] [unique,charset(UTF16)] */,
							  uint32_t _dns_ttl /* [in]  */,
							  struct NL_DNS_NAME_INFO_ARRAY *_dns_names /* [in,out] [ref] */,
							  NTSTATUS *result)
{
	struct winbind_DsrUpdateReadOnlyServerDnsRecords r;
	NTSTATUS status;

	/* In parameters */
	r.in.site_name = _site_name;
	r.in.dns_ttl = _dns_ttl;
	r.in.dns_names = _dns_names;

	status = dcerpc_winbind_DsrUpdateReadOnlyServerDnsRecords_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_dns_names = *r.out.dns_names;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

