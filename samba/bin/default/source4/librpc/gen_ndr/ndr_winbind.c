/* parser auto-generated by pidl */

#include "includes.h"
#include "bin/default/source4/librpc/gen_ndr/ndr_winbind.h"

#include "librpc/gen_ndr/ndr_netlogon.h"
#include "librpc/gen_ndr/ndr_lsa.h"
#include "librpc/gen_ndr/ndr_security.h"
#include "librpc/gen_ndr/ndr_idmap.h"
static enum ndr_err_code ndr_push_winbind_get_idmap_level(struct ndr_push *ndr, int ndr_flags, enum winbind_get_idmap_level r)
{
	NDR_CHECK(ndr_push_enum_uint32(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_winbind_get_idmap_level(struct ndr_pull *ndr, int ndr_flags, enum winbind_get_idmap_level *r)
{
	uint32_t v;
	NDR_CHECK(ndr_pull_enum_uint32(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_winbind_get_idmap_level(struct ndr_print *ndr, const char *name, enum winbind_get_idmap_level r)
{
	const char *val = NULL;

	switch (r) {
		case WINBIND_IDMAP_LEVEL_SIDS_TO_XIDS: val = "WINBIND_IDMAP_LEVEL_SIDS_TO_XIDS"; break;
		case WINBIND_IDMAP_LEVEL_XIDS_TO_SIDS: val = "WINBIND_IDMAP_LEVEL_XIDS_TO_SIDS"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

static enum ndr_err_code ndr_push_winbind_information(struct ndr_push *ndr, int flags, const struct winbind_information *r)
{
	NDR_PUSH_CHECK_FN_FLAGS(ndr, flags);
	if (flags & NDR_IN) {
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_winbind_information(struct ndr_pull *ndr, int flags, struct winbind_information *r)
{
	NDR_PULL_CHECK_FN_FLAGS(ndr, flags);
	if (flags & NDR_IN) {
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_winbind_information(struct ndr_print *ndr, const char *name, int flags, const struct winbind_information *r)
{
	ndr_print_struct(ndr, name, "winbind_information");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "winbind_information");
		ndr->depth++;
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "winbind_information");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_winbind_remote_control(struct ndr_push *ndr, int flags, const struct winbind_remote_control *r)
{
	NDR_PUSH_CHECK_FN_FLAGS(ndr, flags);
	if (flags & NDR_IN) {
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_push_NTSTATUS(ndr, NDR_SCALARS, r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_winbind_remote_control(struct ndr_pull *ndr, int flags, struct winbind_remote_control *r)
{
	NDR_PULL_CHECK_FN_FLAGS(ndr, flags);
	if (flags & NDR_IN) {
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_pull_NTSTATUS(ndr, NDR_SCALARS, &r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_winbind_remote_control(struct ndr_print *ndr, const char *name, int flags, const struct winbind_remote_control *r)
{
	ndr_print_struct(ndr, name, "winbind_remote_control");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "winbind_remote_control");
		ndr->depth++;
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "winbind_remote_control");
		ndr->depth++;
		ndr_print_NTSTATUS(ndr, "result", r->out.result);
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_winbind_SamLogon(struct ndr_push *ndr, int flags, const struct winbind_SamLogon *r)
{
	NDR_PUSH_CHECK_FN_FLAGS(ndr, flags);
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->in.logon_level));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->in.logon, r->in.logon_level));
		NDR_CHECK(ndr_push_netr_LogonLevel(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.logon));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->in.validation_level));
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->out.validation, r->in.validation_level));
		NDR_CHECK(ndr_push_netr_Validation(ndr, NDR_SCALARS|NDR_BUFFERS, &r->out.validation));
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->out.authoritative));
		NDR_CHECK(ndr_push_NTSTATUS(ndr, NDR_SCALARS, r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_winbind_SamLogon(struct ndr_pull *ndr, int flags, struct winbind_SamLogon *r)
{
	NDR_PULL_CHECK_FN_FLAGS(ndr, flags);
	if (flags & NDR_IN) {
		ZERO_STRUCT(r->out);

		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->in.logon_level));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->in.logon, r->in.logon_level));
		NDR_CHECK(ndr_pull_netr_LogonLevel(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.logon));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->in.validation_level));
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->out.validation, r->in.validation_level));
		NDR_CHECK(ndr_pull_netr_Validation(ndr, NDR_SCALARS|NDR_BUFFERS, &r->out.validation));
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->out.authoritative));
		NDR_CHECK(ndr_pull_NTSTATUS(ndr, NDR_SCALARS, &r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_winbind_SamLogon(struct ndr_print *ndr, const char *name, int flags, const struct winbind_SamLogon *r)
{
	ndr_print_struct(ndr, name, "winbind_SamLogon");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "winbind_SamLogon");
		ndr->depth++;
		ndr_print_uint16(ndr, "logon_level", r->in.logon_level);
		ndr_print_set_switch_value(ndr, &r->in.logon, r->in.logon_level);
		ndr_print_netr_LogonLevel(ndr, "logon", &r->in.logon);
		ndr_print_uint16(ndr, "validation_level", r->in.validation_level);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "winbind_SamLogon");
		ndr->depth++;
		ndr_print_set_switch_value(ndr, &r->out.validation, r->in.validation_level);
		ndr_print_netr_Validation(ndr, "validation", &r->out.validation);
		ndr_print_uint8(ndr, "authoritative", r->out.authoritative);
		ndr_print_NTSTATUS(ndr, "result", r->out.result);
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_winbind_get_idmap(struct ndr_push *ndr, int flags, const struct winbind_get_idmap *r)
{
	uint32_t cntr_ids_0;
	NDR_PUSH_CHECK_FN_FLAGS(ndr, flags);
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_winbind_get_idmap_level(ndr, NDR_SCALARS, r->in.level));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.count));
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->in.count));
		for (cntr_ids_0 = 0; cntr_ids_0 < r->in.count; cntr_ids_0++) {
			NDR_CHECK(ndr_push_id_map(ndr, NDR_SCALARS, &r->in.ids[cntr_ids_0]));
		}
		for (cntr_ids_0 = 0; cntr_ids_0 < r->in.count; cntr_ids_0++) {
			NDR_CHECK(ndr_push_id_map(ndr, NDR_BUFFERS, &r->in.ids[cntr_ids_0]));
		}
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->in.count));
		for (cntr_ids_0 = 0; cntr_ids_0 < r->in.count; cntr_ids_0++) {
			NDR_CHECK(ndr_push_id_map(ndr, NDR_SCALARS, &r->out.ids[cntr_ids_0]));
		}
		for (cntr_ids_0 = 0; cntr_ids_0 < r->in.count; cntr_ids_0++) {
			NDR_CHECK(ndr_push_id_map(ndr, NDR_BUFFERS, &r->out.ids[cntr_ids_0]));
		}
		NDR_CHECK(ndr_push_NTSTATUS(ndr, NDR_SCALARS, r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_winbind_get_idmap(struct ndr_pull *ndr, int flags, struct winbind_get_idmap *r)
{
	uint32_t size_ids_0 = 0;
	uint32_t cntr_ids_0;
	TALLOC_CTX *_mem_save_ids_0;
	NDR_PULL_CHECK_FN_FLAGS(ndr, flags);
	if (flags & NDR_IN) {
		ZERO_STRUCT(r->out);

		NDR_CHECK(ndr_pull_winbind_get_idmap_level(ndr, NDR_SCALARS, &r->in.level));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->in.count));
		NDR_CHECK(ndr_pull_array_size(ndr, &r->in.ids));
		size_ids_0 = ndr_get_array_size(ndr, &r->in.ids);
		NDR_PULL_ALLOC_N(ndr, r->in.ids, size_ids_0);
		_mem_save_ids_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->in.ids, 0);
		for (cntr_ids_0 = 0; cntr_ids_0 < size_ids_0; cntr_ids_0++) {
			NDR_CHECK(ndr_pull_id_map(ndr, NDR_SCALARS, &r->in.ids[cntr_ids_0]));
		}
		for (cntr_ids_0 = 0; cntr_ids_0 < size_ids_0; cntr_ids_0++) {
			NDR_CHECK(ndr_pull_id_map(ndr, NDR_BUFFERS, &r->in.ids[cntr_ids_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_ids_0, 0);
		if (r->in.ids) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->in.ids, r->in.count));
		}
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_pull_array_size(ndr, &r->out.ids));
		size_ids_0 = ndr_get_array_size(ndr, &r->out.ids);
		NDR_PULL_ALLOC_N(ndr, r->out.ids, size_ids_0);
		_mem_save_ids_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->out.ids, 0);
		for (cntr_ids_0 = 0; cntr_ids_0 < size_ids_0; cntr_ids_0++) {
			NDR_CHECK(ndr_pull_id_map(ndr, NDR_SCALARS, &r->out.ids[cntr_ids_0]));
		}
		for (cntr_ids_0 = 0; cntr_ids_0 < size_ids_0; cntr_ids_0++) {
			NDR_CHECK(ndr_pull_id_map(ndr, NDR_BUFFERS, &r->out.ids[cntr_ids_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_ids_0, 0);
		NDR_CHECK(ndr_pull_NTSTATUS(ndr, NDR_SCALARS, &r->out.result));
		if (r->out.ids) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->out.ids, r->in.count));
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_winbind_get_idmap(struct ndr_print *ndr, const char *name, int flags, const struct winbind_get_idmap *r)
{
	uint32_t cntr_ids_0;
	ndr_print_struct(ndr, name, "winbind_get_idmap");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "winbind_get_idmap");
		ndr->depth++;
		ndr_print_winbind_get_idmap_level(ndr, "level", r->in.level);
		ndr_print_uint32(ndr, "count", r->in.count);
		ndr->print(ndr, "%s: ARRAY(%d)", "ids", (int)r->in.count);
		ndr->depth++;
		for (cntr_ids_0=0;cntr_ids_0<r->in.count;cntr_ids_0++) {
			ndr_print_id_map(ndr, "ids", &r->in.ids[cntr_ids_0]);
		}
		ndr->depth--;
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "winbind_get_idmap");
		ndr->depth++;
		ndr->print(ndr, "%s: ARRAY(%d)", "ids", (int)r->in.count);
		ndr->depth++;
		for (cntr_ids_0=0;cntr_ids_0<r->in.count;cntr_ids_0++) {
			ndr_print_id_map(ndr, "ids", &r->out.ids[cntr_ids_0]);
		}
		ndr->depth--;
		ndr_print_NTSTATUS(ndr, "result", r->out.result);
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_winbind_DsrUpdateReadOnlyServerDnsRecords(struct ndr_push *ndr, int flags, const struct winbind_DsrUpdateReadOnlyServerDnsRecords *r)
{
	NDR_PUSH_CHECK_FN_FLAGS(ndr, flags);
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->in.site_name));
		if (r->in.site_name) {
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(r->in.site_name, CH_UTF16)));
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, 0));
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(r->in.site_name, CH_UTF16)));
			NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->in.site_name, ndr_charset_length(r->in.site_name, CH_UTF16), sizeof(uint16_t), CH_UTF16));
		}
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.dns_ttl));
		if (r->in.dns_names == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_NL_DNS_NAME_INFO_ARRAY(ndr, NDR_SCALARS|NDR_BUFFERS, r->in.dns_names));
	}
	if (flags & NDR_OUT) {
		if (r->out.dns_names == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_NL_DNS_NAME_INFO_ARRAY(ndr, NDR_SCALARS|NDR_BUFFERS, r->out.dns_names));
		NDR_CHECK(ndr_push_NTSTATUS(ndr, NDR_SCALARS, r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_winbind_DsrUpdateReadOnlyServerDnsRecords(struct ndr_pull *ndr, int flags, struct winbind_DsrUpdateReadOnlyServerDnsRecords *r)
{
	uint32_t _ptr_site_name;
	uint32_t size_site_name_1 = 0;
	uint32_t length_site_name_1 = 0;
	TALLOC_CTX *_mem_save_site_name_0;
	TALLOC_CTX *_mem_save_dns_names_0;
	NDR_PULL_CHECK_FN_FLAGS(ndr, flags);
	if (flags & NDR_IN) {
		ZERO_STRUCT(r->out);

		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_site_name));
		if (_ptr_site_name) {
			NDR_PULL_ALLOC(ndr, r->in.site_name);
		} else {
			r->in.site_name = NULL;
		}
		if (r->in.site_name) {
			_mem_save_site_name_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->in.site_name, 0);
			NDR_CHECK(ndr_pull_array_size(ndr, &r->in.site_name));
			NDR_CHECK(ndr_pull_array_length(ndr, &r->in.site_name));
			size_site_name_1 = ndr_get_array_size(ndr, &r->in.site_name);
			length_site_name_1 = ndr_get_array_length(ndr, &r->in.site_name);
			if (length_site_name_1 > size_site_name_1) {
				return ndr_pull_error(ndr, NDR_ERR_ARRAY_SIZE, "Bad array size %u should exceed array length %u", size_site_name_1, length_site_name_1);
			}
			NDR_CHECK(ndr_check_string_terminator(ndr, length_site_name_1, sizeof(uint16_t)));
			NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->in.site_name, length_site_name_1, sizeof(uint16_t), CH_UTF16));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_site_name_0, 0);
		}
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->in.dns_ttl));
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->in.dns_names);
		}
		_mem_save_dns_names_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->in.dns_names, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_NL_DNS_NAME_INFO_ARRAY(ndr, NDR_SCALARS|NDR_BUFFERS, r->in.dns_names));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_dns_names_0, LIBNDR_FLAG_REF_ALLOC);
		NDR_PULL_ALLOC(ndr, r->out.dns_names);
		*r->out.dns_names = *r->in.dns_names;
	}
	if (flags & NDR_OUT) {
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->out.dns_names);
		}
		_mem_save_dns_names_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->out.dns_names, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_NL_DNS_NAME_INFO_ARRAY(ndr, NDR_SCALARS|NDR_BUFFERS, r->out.dns_names));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_dns_names_0, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_NTSTATUS(ndr, NDR_SCALARS, &r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_winbind_DsrUpdateReadOnlyServerDnsRecords(struct ndr_print *ndr, const char *name, int flags, const struct winbind_DsrUpdateReadOnlyServerDnsRecords *r)
{
	ndr_print_struct(ndr, name, "winbind_DsrUpdateReadOnlyServerDnsRecords");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "winbind_DsrUpdateReadOnlyServerDnsRecords");
		ndr->depth++;
		ndr_print_ptr(ndr, "site_name", r->in.site_name);
		ndr->depth++;
		if (r->in.site_name) {
			ndr_print_string(ndr, "site_name", r->in.site_name);
		}
		ndr->depth--;
		ndr_print_uint32(ndr, "dns_ttl", r->in.dns_ttl);
		ndr_print_ptr(ndr, "dns_names", r->in.dns_names);
		ndr->depth++;
		ndr_print_NL_DNS_NAME_INFO_ARRAY(ndr, "dns_names", r->in.dns_names);
		ndr->depth--;
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "winbind_DsrUpdateReadOnlyServerDnsRecords");
		ndr->depth++;
		ndr_print_ptr(ndr, "dns_names", r->out.dns_names);
		ndr->depth++;
		ndr_print_NL_DNS_NAME_INFO_ARRAY(ndr, "dns_names", r->out.dns_names);
		ndr->depth--;
		ndr_print_NTSTATUS(ndr, "result", r->out.result);
		ndr->depth--;
	}
	ndr->depth--;
}

static const struct ndr_interface_call winbind_calls[] = {
	{
		"winbind_information",
		sizeof(struct winbind_information),
		(ndr_push_flags_fn_t) ndr_push_winbind_information,
		(ndr_pull_flags_fn_t) ndr_pull_winbind_information,
		(ndr_print_function_t) ndr_print_winbind_information,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"winbind_remote_control",
		sizeof(struct winbind_remote_control),
		(ndr_push_flags_fn_t) ndr_push_winbind_remote_control,
		(ndr_pull_flags_fn_t) ndr_pull_winbind_remote_control,
		(ndr_print_function_t) ndr_print_winbind_remote_control,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"winbind_SamLogon",
		sizeof(struct winbind_SamLogon),
		(ndr_push_flags_fn_t) ndr_push_winbind_SamLogon,
		(ndr_pull_flags_fn_t) ndr_pull_winbind_SamLogon,
		(ndr_print_function_t) ndr_print_winbind_SamLogon,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"winbind_get_idmap",
		sizeof(struct winbind_get_idmap),
		(ndr_push_flags_fn_t) ndr_push_winbind_get_idmap,
		(ndr_pull_flags_fn_t) ndr_pull_winbind_get_idmap,
		(ndr_print_function_t) ndr_print_winbind_get_idmap,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"winbind_DsrUpdateReadOnlyServerDnsRecords",
		sizeof(struct winbind_DsrUpdateReadOnlyServerDnsRecords),
		(ndr_push_flags_fn_t) ndr_push_winbind_DsrUpdateReadOnlyServerDnsRecords,
		(ndr_pull_flags_fn_t) ndr_pull_winbind_DsrUpdateReadOnlyServerDnsRecords,
		(ndr_print_function_t) ndr_print_winbind_DsrUpdateReadOnlyServerDnsRecords,
		{ 0, NULL },
		{ 0, NULL },
	},
	{ NULL, 0, NULL, NULL, NULL }
};

static const char * const winbind_endpoint_strings[] = {
	"ncacn_np:[\\pipe\\winbind]", 
};

static const struct ndr_interface_string_array winbind_endpoints = {
	.count	= 1,
	.names	= winbind_endpoint_strings
};

static const char * const winbind_authservice_strings[] = {
	"host", 
};

static const struct ndr_interface_string_array winbind_authservices = {
	.count	= 1,
	.names	= winbind_authservice_strings
};


const struct ndr_interface_table ndr_table_winbind = {
	.name		= "winbind",
	.syntax_id	= {
		{0x245f3e6b,0x3c5d,0x6e21,{0x3a,0x2d},{0x2a,0x3d,0x64,0x5b,0x72,0x21}},
		NDR_WINBIND_VERSION
	},
	.helpstring	= NDR_WINBIND_HELPSTRING,
	.num_calls	= 5,
	.calls		= winbind_calls,
	.endpoints	= &winbind_endpoints,
	.authservices	= &winbind_authservices
};

